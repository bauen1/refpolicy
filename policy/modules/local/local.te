policy_module(local, 1.0)

gen_require(`
    attribute systemd_user_session_type;

    role staff_r;
    role user_r;

    type staff_systemd_t;
    type system_dbusd_t;
    type system_dbusd_runtime_t;
    type staff_t;
    type user_t;
    type staff_systemd_t;
    type user_tmp_t;
    type user_systemd_t;
    type systemd_unit_t;
    type xdg_data_t;
    type xdg_config_t;
    type home_root_t;
    type user_home_dir_t;
    type xdg_config_t;
    type cgroup_t;
    type sysctl_crypto_t;
    type user_home_t;
    type xdg_config_t;
    type systemd_user_runtime_t;
    type systemd_user_runtime_notify_t;
    type tmpfs_t;
    type console_device_t;
    type user_runtime_t;
    type lib_t;

    class netlink_selinux_socket { read };
    class process { noatsecure rlimitinh siginh sigkill signal signull getcap getsched execmem ptrace };
    class process2 { nnp_transition };
    class unix_stream_socket { getattr read write ioctl connectto };
')

gen_require(`
    attribute session_bus_type;
    attribute systemd_user_session_type;
    class cap_userns { sys_admin sys_ptrace kill };
    class tcp_socket { name_bind };
    type devicekit_power_t;
    type gconfd_t;
    type gconf_tmp_t;
    type gnome_xdg_config_t;
    type gpg_agent_t;
    type initrc_t;
    type init_runtime_t;
    type init_t;
    type kernel_t;
    type lvm_t;
    type mpd_port_t;
    type pstore_t;
    type pulseaudio_t;
    type session_dbusd_runtime_t;
    type staff_dbusd_t;
    type sysfs_t;
    type syslogd_t;
    type systemd_user_runtime_t;
    type udevadm_t;
    type udev_runtime_t;
    type user_dbusd_t;
    type var_lib_t;
    type var_lock_t;
    type xdg_config_t;
    type xdg_data_t;
    type xdm_var_lib_t;
')

# xfce4-screensaver probably
allow staff_t console_device_t:chr_file { write };

# FIXME: not required ?
allow staff_dbusd_t systemd_user_runtime_t:dir getattr;

# XXX: this really should not be allowed
allow staff_t session_dbusd_runtime_t:sock_file write;
allow user_t session_dbusd_runtime_t:sock_file write;

# XXX: only required by systemd for lightdm
allow user_systemd_t xdm_var_lib_t:dir { getattr search };
allow user_dbusd_t xdm_var_lib_t:dir { search };
allow mpd_t xdm_var_lib_t:dir { search };
allow gpg_agent_t xdm_var_lib_t:dir { getattr search setattr };
allow pulseaudio_t xdm_var_lib_t:dir { search };

#============ lvm_t ============
# lvm2 fix boot
allow lvm_t pstore_t:dir search;
allow lvm_t tmpfs_t:dir { manage_dir_perms };
allow lvm_t tmpfs_t:file { manage_file_perms };

# init lvm2
allow initrc_t lvm_t:process2 { nnp_transition };

# systemd boot (FIXME: are all required ?)
allow init_t initrc_t:process2 { nnp_transition };
allow init_t self:cap_userns { kill sys_admin setpcap setuid };

# FIXME: why ??
allow syslogd_t self:cap_userns { sys_ptrace };

#============ udevadm_t ============
# fix udevadm_t boot (invoked by systemd unit)
allow udevadm_t udev_runtime_t:file { open read };
allow udevadm_t var_lock_t:file write;

# misc. dbusd stuff
allow session_bus_type system_dbusd_t:dbus send_msg;
allow session_bus_type system_dbusd_t:unix_stream_socket connectto;

allow staff_dbusd_t xdg_config_t:dir { manage_dir_perms };
allow staff_dbusd_t xdg_config_t:file { manage_file_perms };

# more staff_dbusd_t misc. stuff
allow staff_t staff_dbusd_t:unix_stream_socket { read write getattr ioctl };
allow user_t user_dbusd_t:unix_stream_socket { read write getattr };

# staff_dbusd_t: might be necessary, not sure
allow session_bus_type system_dbusd_runtime_t:dir search;
allow session_bus_type system_dbusd_runtime_t:sock_file write;
allow staff_dbusd_t xdg_data_t:dir { search };

# might be necessary
allow session_bus_type init_t:dbus send_msg;
allow staff_t init_t:dbus send_msg;
allow staff_t initrc_t:dbus send_msg;

# staff_t: might be required by user@.service (TODO: double check)
allow staff_t init_t:fd use;

# FIXME: might be unecessary but seems sensible
allow devicekit_power_t initrc_t:dbus send_msg;

allow session_bus_type sysfs_t:file { open read };

dontaudit staff_dbusd_t staff_t:process { noatsecure rlimitinh siginh };
dontaudit user_dbusd_t user_t:process { noatsecure rlimitinh siginh };

# FIXME: shouldn't be allowed
allow user_t tmpfs_t:file { read write };

# maybe required
allow systemd_user_session_type system_dbusd_runtime_t:dir search;

## staff_systemd_t: misc.
# a lot of systemd --user socket activation bullshit
# this really depends, because of these rules /run/user/$uid/dbus + etc end up being mislabeled

userdom_user_runtime_filetrans(staff_systemd_t, gconf_tmp_t, dir, "dconf")

# FIXME: this shouldn't be necessary
userdom_user_runtime_filetrans(staff_dbusd_t, gconf_tmp_t, dir, "dconf")

# gsettings-helper
allow gconfd_t session_dbusd_runtime_t:sock_file write;
allow gconfd_t sysfs_t:dir read;
allow gconfd_t usr_t:file { getattr map };
allow gconfd_t gnome_xdg_config_t:file map;

# FIXME: should not be required (map => pulseaudio gsettings-helper )
allow gconfd_t user_tmp_t:file { read write open map };
auditallow gconfd_t user_tmp_t:file { read write open map };

# might not be required
allow staff_t gconf_tmp_t:file map;

allow systemd_user_session_type gconfd_t:process signal;
allow staff_systemd_t user_tmp_t:dir { add_name getattr remove_name write };
allow staff_systemd_t user_tmp_t:sock_file { create unlink write };
auditallow staff_systemd_t user_tmp_t:dir { add_name getattr remove_name write };
auditallow staff_systemd_t user_tmp_t:sock_file { create unlink write };

allow staff_systemd_t xdg_data_t:dir search;

# this probably shouldn't be allowed, but oh well
allow systemd_user_session_type init_runtime_t:sock_file write;

# might be required
allow systemd_user_session_type mpd_port_t:tcp_socket name_bind;

# FIXME: might be related to dotfiles
allow staff_systemd_t xdg_config_t:lnk_file read;

# allow execution of ~/.local/bin/*
# FIXME: shouldn't be required
allow staff_t xdg_data_t:file execute;
allow staff_t xdg_data_t:file execute_no_trans;
#auditallow staff_t xdg_data_t:file execute;
#auditallow staff_t xdg_data_t:file execute_no_trans;

# fix ansible (should probably be fixed by changing the label of the directory with the master sockets)
require {
    type ssh_t;
    type user_home_t;
    type ssh_exec_t;
    type sysadm_t;
    type selinux_config_t;
    class icmp_socket { create };
    class rawip_socket { create getopt read setopt write };
    class capability { net_raw };
    type dri_device_t;
    class chr_file { getattr ioctl open read write };
}
allow ssh_t user_home_t:dir { search write add_name remove_name };
allow ssh_t user_home_t:sock_file { create link unlink write };
allow ssh_t ssh_exec_t:file execute_no_trans;

# allow building in /etc/selinux/refpolicy/src
allow sysadm_t selinux_config_t:file { execute execute_no_trans };

# maybe required for ssh-agent launch script
allow staff_t system_dbusd_t:dir { open read getattr search };
allow staff_t system_dbusd_t:file { getattr open read };
allow staff_t system_dbusd_t:lnk_file read;

# allow ICMP ping by staff_t
allow staff_t self:icmp_socket create;
allow staff_t self:rawip_socket { create getopt read setopt write };
allow staff_t self:capability net_raw;

# might want to allow this
gen_require(`
    type dri_device_t;
    class changing { rw_chr_file_perms map };
')
allow staff_t dri_device_t:chr_file { rw_chr_file_perms map };
allow thunderbird_t dri_device_t:chr_file rw_chr_file_perms;

# might be  required for dbus / pulseaudio
allow staff_t systemd_logind_t:dir { getattr search read open };
allow staff_t systemd_logind_t:file { getattr open read };

# some of these might be necessary
allow staff_t init_t:dir { getattr open read search };
allow staff_t init_t:file { getattr open read };
allow staff_t init_t:lnk_file read;
allow staff_t initrc_t:dir { getattr open search read };
allow staff_t initrc_t:file { getattr open read };
allow staff_t initrc_t:lnk_file { read };

#============ xserver_t ============
# might be required ??
allow xserver_t self:process execmem;
allow staff_t xserver_t:dir { getattr open read search };
allow staff_t xserver_t:file { getattr open read };
allow staff_t xserver_t:lnk_file read;

#============= devicekit_disk_t ==============
require {
    type policykit_t;
    type systemd_logind_t;
    type xserver_t;
    type devicekit_disk_t;
    type devicekit_power_t;
}
allow staff_t policykit_t:dir { getattr open read search };
allow staff_t policykit_t:file { getattr open read };
allow staff_t policykit_t:lnk_file read;
allow staff_t devicekit_disk_t:dir { getattr search open read };
allow staff_t devicekit_disk_t:file { getattr open read };
allow staff_t devicekit_power_t:dir { getattr search open read };
allow staff_t devicekit_power_t:file { getattr open read };
allow staff_t devicekit_power_t:lnk_file read;

allow devicekit_disk_t tmpfs_t:dir { add_name remove_name write };
allow devicekit_disk_t tmpfs_t:file { create lock open read unlink write };

#============= mozilla_t ==============
# probably not required
require {
    type mozilla_t;
    type gconf_tmp_t;
    type gnome_xdg_config_t;
    type staff_screen_t;
    class unix_stream_socket { ioctl read write };
    type local_login_t;
    type cgroup_t;
    type staff_screen_t;
    type user_home_t;
    type utempter_t;
}
devicekit_dbus_chat(devicekit_power_t)
allow mozilla_t session_dbusd_runtime_t:sock_file { getattr write };
allow mozilla_t staff_systemd_t:unix_stream_socket connectto;
allow mozilla_t var_lib_t:file map;
allow mozilla_t gconf_tmp_t:dir { write };
allow mozilla_t gconf_tmp_t:file { open read write map };
gnome_stream_connect_gconf(mozilla_t)
allow mozilla_t gnome_xdg_config_t:file map;
allow mozilla_t self:process ptrace;

# probably not required
allow staff_t init_t:unix_stream_socket { getattr ioctl read write append };
allow user_t init_t:unix_stream_socket { getattr ioctl read write append };

#============ staff_screen_t ============
# sensible, but might not be necessary
allow staff_t staff_screen_t:unix_stream_socket { ioctl read write getattr };
dontaudit staff_t staff_screen_t:process { noatsecure rlimitinh siginh };

#============= local_login_t ==============
# sensible, but might not be necessary

allow local_login_t cgroup_t:dir { getattr open setattr read write search remove_name rmdir };
allow local_login_t cgroup_t:file { getattr open read write };
allow local_login_t cgroup_t:lnk_file read;
allow local_login_t tmpfs_t:filesystem getattr;

#============= staff_screen_t ==============
# tmux-resurrect
allow staff_screen_t user_home_t:dir { manage_dir_perms };
allow staff_screen_t user_home_t:file { manage_file_perms };

# dunno
auth_run_utempter(staff_screen_t, staff_r)
allow utempter_t staff_screen_t:unix_stream_socket { read write };

# dontaudit
require {
    type autofs_device_t;
    type auditctl_t;
    type auditd_etc_t;
}
dontaudit staff_sudo_t autofs_device_t:chr_file getattr;
dontaudit auditctl_t auditd_etc_t:file map;

# FIXME: probably shouldn't be allowed
systemd_write_inherited_logind_inhibit_pipes(staff_t)

# seems somewhat sensible
require {
    type staff_gkeyringd_t;
}
allow staff_gkeyringd_t systemd_logind_t:dbus send_msg;
allow systemd_logind_t staff_gkeyringd_t:dbus send_msg;
allow systemd_logind_t initrc_t:dir search;
allow systemd_logind_t initrc_t:file { open read };

allow staff_gkeyringd_t session_dbusd_runtime_t:sock_file write;
allow staff_gkeyringd_t staff_dbusd_t:unix_stream_socket { getattr ioctl read write };
allow staff_gkeyringd_t staff_systemd_t:unix_stream_socket connectto;

# xfce4 wants to map some sort of cache
require {
    type var_lib_t;
}
allow staff_t var_lib_t:file map;

# probably not necessary
require {
    type staff_ssh_agent_t;
    type xsession_log_t;
}
allow staff_t staff_ssh_agent_t:process signull;

# FIXME: required ?
require {
    type staff_sudo_t;
}
allow staff_sudo_t init_t:dir search;
allow staff_sudo_t init_t:file { getattr open read };
allow staff_sudo_t staff_t:dir search;
allow staff_sudo_t staff_t:file { getattr open read };
allow staff_sudo_t cgroup_t:dir { getattr search read write add_name create open setattr remove_name rmdir };
allow staff_sudo_t cgroup_t:file { getattr open read write };
allow staff_sudo_t tmpfs_t:filesystem getattr;

require {
    type initctl_t;
    type local_login_t;
}
allow staff_sudo_t initctl_t:fifo_file getattr;
allow staff_sudo_t local_login_t:dir search;
allow staff_sudo_t local_login_t:file { open read };

# might not be required
require {
    type sysadm_t;
    type systemd_logind_t;
    type systemd_hostnamed_t;
}
allow sysadm_t systemd_logind_t:dbus send_msg;
allow systemd_hostnamed_t initrc_t:dbus send_msg;

#============= udevadm_t ==============
# might not be required
require {
    type udevadm_t;
    type fixed_disk_device_t;
    type initrc_lock_t;
    class blk_file { getattr };
}
allow udevadm_t fixed_disk_device_t:blk_file getattr;
allow udevadm_t initrc_lock_t:file write;

#============= virtd_t ==============
require {
    type virtd_t;
    type init_t;
    type systemd_logind_t;
}
allow virtd_t init_t:dbus send_msg;
allow virtd_t systemd_logind_t:dbus send_msg;
allow systemd_logind_t virtd_t:dbus send_msg;

# might be pkexec too
require {
    type xdg_cache_t;
}
allow policykit_t xdg_cache_t:dir search;

# htop
require {
    type crond_t;
    type automount_t;
    type xdm_t;
    type rtkit_daemon_t;
    type getty_t;
    type mpd_t;
}
allow staff_t kernel_t:dir search;
allow staff_t kernel_t:file read;
allow staff_t crond_t:dir search;
allow staff_t crond_t:file read;
allow staff_t automount_t:dir search;
allow staff_t automount_t:file read;
allow staff_t xdm_t:dir search;
allow staff_t xdm_t:file read;
allow staff_t getty_t:dir search;
allow staff_t getty_t:file read;
allow staff_t mpd_t:dir { getattr search };
dontaudit staff_t rtkit_daemon_t:dir search;

# more dontaudit stuff
require {
    type staff_screen_t;
    type staff_sudo_t;
}
dontaudit staff_t staff_screen_t:process { noatsecure rlimitinh siginh };
dontaudit staff_t staff_sudo_t:process { noatsecure rlimitinh siginh };

# allow semodule to access /etc/selinux/local-policies
require {
    type load_policy_t;
    type selinux_config_t;
}
allow load_policy_t selinux_config_t:file map;

## qemu
qemu_role(staff_r, staff_t)
require {
    type qemu_t;
    type user_home_t;
}

allow qemu_t user_home_t:file { getattr read open lock };
allow qemu_t session_dbusd_runtime_t:sock_file write;
allow qemu_t staff_dbusd_t:unix_stream_socket connectto;
allow qemu_t systemd_user_session_type:unix_stream_socket connectto;
allow qemu_t xdg_data_t:file { getattr map open read };
allow qemu_t usr_t:file map;
dontaudit staff_t qemu_t:process { siginh rlimitinh noatsecure };

# laptop_mode / udev
require {
    type udev_t;
    type sysctl_fs_t;
    type sysctl_kernel_t;
    type sysctl_vm_t;
    type var_lock_t;
    type var_run_t;
    type xdm_tmp_t;
}
allow udev_t sysctl_fs_t:dir search;
allow udev_t sysctl_kernel_t:file write;
allow udev_t sysctl_vm_t:file write;
allow udev_t usr_t:file execute;
allow udev_t var_lock_t:file { lock open write };
allow udev_t var_lock_t:dir { add_name write };
allow udev_t var_run_t:file { append create getattr ioctl open read rename setattr unlink write };
allow udev_t xdm_tmp_t:dir { getattr open read };
allow udev_t xdm_tmp_t:sock_file getattr;
allow udev_t initrc_lock_t:file write;

# FIXME: why, probably not required
require {
    type udev_t;
}
allow staff_t udev_t:dir search;

# FIXME: this should not be allowed, probably mislabeled files
require {
    type systemd_unit_t;
    # type systemd_user_runtime_t;
    class service { start status };
}
allow staff_t xdg_config_t:service { start status };
# allow staff_t systemd_user_runtime_t:service { start };

# probably to allow docker access
allow sysadm_t initrc_t:unix_stream_socket connectto;

# FIXME: shouldn't be allowed
require {
    type unlabeled_t;
    class key { create };
}
allow initrc_t unlabeled_t:key create;

# pihole
allow initrc_t var_lib_t:file execmod;

#============= thunderbird_t ==============
require {
    type thunderbird_t;
    type thunderbird_home_t;
    type tmp_t;
}
allow thunderbird_t bin_t:file { execute getattr open read execute_no_trans map ioctl };
allow thunderbird_t session_dbusd_runtime_t:sock_file write;
kernel_read_crypto_sysctls(thunderbird_t)
allow thunderbird_t sysfs_t:dir read;
allow thunderbird_t sysfs_t:file { getattr open read };
allow thunderbird_t sysfs_t:lnk_file { getattr read };
allow thunderbird_t staff_systemd_t:unix_stream_socket connectto;
allow thunderbird_t var_lib_t:file { getattr open read map };
allow thunderbird_t thunderbird_home_t:file map;
allow thunderbird_t tmp_t:dir { write add_name };
allow thunderbird_t tmp_t:file { create open write };
allow thunderbird_t self:process ptrace;
allow thunderbird_t user_tmp_t:file map;
auditallow thunderbird_t user_tmp_t:file map;

require {
    type dpkg_t;
}
allow sysadm_t dpkg_t:process2 nnp_transition;

# docker
allow initrc_t self:process execmem;

# FIXME: ???
require {
    type node_t;
    type unreserved_port_t;
}
allow sysadm_t node_t:tcp_socket node_bind;
allow staff_t unreserved_port_t:udp_socket name_bind;
allow staff_t unreserved_port_t:tcp_socket name_bind;

# 'ss'
allow sysadm_t self:netlink_tcpdiag_socket create;

# misc.
require {
    type unreserved_port_t;
    type net_conf_t;
    class tcp_socket { name_connect };
}
allow staff_systemd_t unreserved_port_t:tcp_socket name_connect;
allow staff_systemd_t node_t:udp_socket node_bind;

require {
    type xserver_tmpfs_t;
}
allow staff_t xserver_tmpfs_t:file map;
allow staff_dbusd_t self:unix_stream_socket connectto;

# FIXME: flatpak run
require {
    type fuse_device_t;
    type boot_t;
}
allow staff_t boot_t:lnk_file read;
allow staff_t fuse_device_t:chr_file { open read write };
allow staff_systemd_t fuse_device_t:chr_file getattr;
allow staff_t user_home_t:file execmod;
allow staff_systemd_t systemd_user_runtime_t:file { create getattr open unlink write };
allow staff_t var_lib_t:file { execute execute_no_trans };
allow staff_t self:capability { net_admin dac_read_search };

# allow access to bluetooth
require {
    class bluetooth_socket { bind create getopt ioctl read setopt write };
}
allow staff_t self:bluetooth_socket { bind create getopt ioctl read setopt write };
allow system_dbusd_t initrc_t:bluetooth_socket { read write };

# FIXME anime httpd ?
allow staff_t systemd_unit_t:service status;

# FIXME: not required for boot
require {
    type alsa_t;
    type var_run_t;
}
allow alsa_t self:process { getsched setsched signal };
allow alsa_t var_run_t:file { manage_file_perms };

# seems reasonable
require {
    type colord_t;
    type colord_exec_t;
}
allow colord_t colord_exec_t:file execute_no_trans;

# fix gconfd (and a lot of stuff)
require {
    type gconf_tmp_t;
}
userdom_user_runtime_filetrans(gconfd_t, gconf_tmp_t, dir, "dconf")

# pip3
allow staff_t user_tmp_t:file { relabelfrom relabelto };
allow staff_t user_tmp_t:dir { relabelfrom relabelto };

# avahi browser
allow staff_t lib_t:file lock;
avahi_dbus_chat(staff_t)

# allow ssh to connect to anything
require {
    type ssh_t;
    type unreserved_port_t;
}
allow ssh_t unreserved_port_t:tcp_socket name_connect;

#============= virtlogd_t ==============
require {
    type virtlogd_t;
    type virt_runtime_t;
    type svirt_t;
    type udev_runtime_t;
}
allow virtlogd_t self:unix_stream_socket { listen accept };
allow virtlogd_t virt_runtime_t:sock_file { manage_sock_file_perms };
allow virtlogd_t self:process getsched;
allow svirt_t udev_runtime_t:file { open read getattr };

# apt notify
require {
    type apt_t;
}
allow sysadm_t apt_t:dbus send_msg;

# discord flatpak
allow staff_t user_tmp_t:dir mounton;
fs_read_tmpfs_symlinks(staff_t)
fs_rw_tmpfs_files(staff_t)
allow staff_t tmpfs_t:file map;

# docker without sudo
allow staff_t var_run_t:sock_file write;
init_stream_connect_script(staff_t)
